# 04_flow.md - 開発フロー

## タスク受領から完了までのフロー

### 標準開発フロー

```mermaid
graph TD
    A[タスク受領] --> B[/core 確認]
    B --> C[既存コード調査]
    C --> D{Legacy変更必要？}
    D -->|Yes| E[人間に相談]
    D -->|No| F[実装方針決定]
    E --> F
    F --> G[実装]
    G --> H[自己レビュー]
    H --> I{問題なし？}
    I -->|No| G
    I -->|Yes| J[報告]
    J --> K{追加作業必要？}
    K -->|Yes| A
    K -->|No| L[完了]
```

### 詳細ステップ

#### 1. タスク受領

```markdown
## 受領時に確認すること

- [ ] 要件が明確か？
- [ ] 期待される成果物は？
- [ ] 優先度は？
- [ ] 制約条件はあるか？
```

#### 2. /core 確認

```bash
# 必ず確認するドキュメント
1. 00_concept.md - プロジェクト方針に合致？
2. 01_agent_role.md - 自分の権限内？
3. 02_rules.md - コーディング規約確認
4. 03_domain.md - ドメイン知識確認
5. 05_decisions.md - 過去の意思決定確認
```

#### 3. 既存コード調査

```typescript
// 調査すべきファイル
1. 型定義: apps/web/src/types/index.ts
2. 関連API: backend/functions/src/api/*.ts
3. 関連ページ: apps/web/src/app/**/page.tsx
4. Store: apps/web/src/stores/*.ts
```

#### 4. 実装

```typescript
// 実装の順序
1. 型定義（types/index.ts）
2. バックエンドAPI（backend/functions/src/api/）
3. Store（apps/web/src/stores/）
4. UI（apps/web/src/app/）
5. テスト（Emulator）
```

#### 5. 自己レビュー

02_rules.md の「セルフレビューチェックリスト」を実施

#### 6. 報告

```markdown
## 完了報告テンプレート

### 実装内容
[何を実装したか]

### 変更ファイル
- file_path:line_start-line_end

### テスト方法
[Emulatorでの確認手順]

### 影響範囲
[この変更が影響する範囲]

### 次のステップ
[追加で必要な作業があれば]
```

## 機能別フロー

### 新規API実装フロー

```
1. 型定義作成（types/index.ts）
   ↓
2. Zodスキーマ作成（api/*.ts）
   ↓
3. Function実装（backend/functions/src/api/*.ts）
   - requireAuth
   - requireTenantAccess
   - ビジネスロジック
   - エラーハンドリング
   ↓
4. エクスポート追加（backend/functions/src/index.ts）
   ↓
5. Emulatorでテスト
   ↓
6. 完了報告
```

### 新規ページ実装フロー

```
1. ページファイル作成（apps/web/src/app/**/page.tsx）
   ↓
2. Store作成（必要なら）（apps/web/src/stores/*.ts）
   ↓
3. コンポーネント作成（apps/web/src/components/**/*.tsx）
   ↓
4. APIコール実装（Firebase Functionsを呼び出し）
   ↓
5. スタイリング（Tailwind CSS）
   ↓
6. ローカルでテスト（npm run dev:web）
   ↓
7. 完了報告
```

### バグ修正フロー

```
1. バグ再現確認
   ↓
2. 原因特定（ログ確認、デバッグ）
   ↓
3. 修正範囲決定
   - Legacy変更必要？ → 人間に相談
   - 新規コードのみ？ → 修正実施
   ↓
4. 修正実装
   ↓
5. テスト（再現しないことを確認）
   ↓
6. Legacy変更時は 05_decisions.md に記録
   ↓
7. 完了報告
```

### リファクタリングフロー

```
1. リファクタリング対象特定
   ↓
2. 影響範囲調査
   - Breaking Change になるか？
   - Legacy変更が必要か？
   ↓
3. 人間に相談（必要なら）
   ↓
4. リファクタリング実施
   - テストを書く（可能なら）
   - 段階的に実施
   ↓
5. 動作確認
   ↓
6. 完了報告
```

## タスク優先順位の決め方

### 優先度マトリクス

```
          重要度
          ↑
      高  |  P1  |  P2  |
          |-----|-----|
      低  |  P3  |  P4  |
          +------------→ 緊急度
          低    高
```

**P1（最優先）**:
- セキュリティ脆弱性
- データ損失リスク
- サービス停止リスク

**P2（高優先）**:
- 主要機能のバグ
- パフォーマンス問題
- ユーザーブロッカー

**P3（中優先）**:
- 新機能実装
- UI/UX改善
- リファクタリング

**P4（低優先）**:
- 細かいUI調整
- ドキュメント整備
- 技術的負債（緊急性低）

### 判断基準

```
if (セキュリティリスク || データ損失リスク) {
  return "P1 - 即座に対応";
}

if (機能が使えない || 重大なエラー) {
  return "P2 - 優先的に対応";
}

if (新機能実装 || 改善要望) {
  return "P3 - 計画的に対応";
}

return "P4 - 余裕があれば対応";
```

## 並行作業の方針

### 並行可能なタスク

- 独立した機能の実装
- 異なるページの実装
- ドキュメント作成 + コード実装

### 並行不可のタスク

- データモデル変更 + それを使う機能実装
- API変更 + そのAPIを使うUI実装
- 同一ファイルの修正

### 並行作業時の注意

```bash
# ブランチを分ける
git checkout -b feature/customer-search
git checkout -b feature/appointment-filter

# マージ順序を考慮
# 依存関係のないものから先にマージ
```

## デプロイフロー

### 開発環境（Emulator）

```bash
# 1. Functions ビルド
cd backend/functions
npm run build

# 2. Emulator 起動
cd ../..
firebase emulators:start

# 3. Web 起動（別ターミナル）
npm run dev:web

# 4. テスト実施
# http://localhost:3006 でアクセス
# http://localhost:4000 で Emulator UI
```

### 本番環境（人間が指示時に実施）

```bash
# ⚠️ エージェントは実行しない
# ⚠️ 人間の明示的な指示があった場合のみデプロイ

# 1. ビルド
npm run build

# 2. デプロイ
firebase deploy --only functions
vercel deploy --prod

# 3. 動作確認

# 注意：定期デプロイはなし、オンデマンドのみ
```

## エラー発生時のフロー

### エラー分類

**Type 1: 実装ミス**
```
原因: コードのタイポ、ロジックミス
対応: 即座に修正
```

**Type 2: 仕様不明確**
```
原因: 要件が不明確、ドメイン知識不足
対応: 人間に質問
```

**Type 3: 環境問題**
```
原因: Firebase設定、環境変数
対応: 人間に報告（エージェントでは解決不可）
```

**Type 4: 外部API問題**
```
原因: Stripe、LINE APIのエラー
対応: ドキュメント確認 → 解決できなければ報告
```

### エラーハンドリングフロー

```
1. エラー発生
   ↓
2. エラーメッセージ確認
   ↓
3. ログ確認（Emulator UI）
   ↓
4. 原因特定
   ↓
5. 解決策検討
   - 自分で解決可能？
   - 人間への相談必要？
   ↓
6. 修正 or 報告
```

## コミュニケーションフロー

### 質問のタイミング

```
即座に質問:
- セキュリティに影響
- Breaking Change の可能性
- ビジネスロジック不明

実装後に報告:
- 軽微なバグ修正
- コードの改善提案
- ドキュメント追加
```

### 質問フォーマット

```markdown
## 質問: [タイトル]

### 背景
[なぜこの質問が発生したか]

### 現状
[今どういう状況か]

### 選択肢
1. 案A: [説明] - メリット/デメリット
2. 案B: [説明] - メリット/デメリット

### 推奨
案Aを推奨します。理由: [...]

### 質問
どちらで進めますか？
```

## イテレーション

### 1週間のサイクル

```
月曜:
- 今週のタスク確認
- 優先順位整理

火〜木:
- タスク実装
- レビュー・修正

金曜:
- 完了確認
- ドキュメント更新
- 来週の計画
```

### フィードバックループ

```
実装 → テスト → フィードバック → 改善 → 実装...
```

## 継続的改善

### 定期レビュー

**月次**:
- /core ドキュメント見直し
- 開発フローの改善点抽出

**四半期**:
- プロジェクト方針の見直し
- 技術スタックのアップデート検討

### 改善提案

エージェントから改善提案する場合：

```markdown
## 改善提案: [タイトル]

### 現状の問題
[何が問題か]

### 提案内容
[どう改善するか]

### 期待効果
- 開発速度向上
- バグ削減
- 保守性向上

### 導入コスト
- 実装時間: [X時間]
- 学習コスト: [低/中/高]

### 判断
このタイミングで導入すべきか、ご意見ください。
```

---

**最終更新**: 2026-01-23
**次回見直し**: 月次レビュー時
