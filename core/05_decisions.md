# 05_decisions.md - 意思決定記録

## 記録の目的

このドキュメントは、プロジェクトにおける重要な意思決定を記録し、将来の参照と学習のために保存します。

特に **legacy コードへの変更** は必ずここに記録します。

---

## 記録形式

各意思決定は以下の形式で記録してください：

```markdown
## [YYYY-MM-DD] 決定事項のタイトル

### 状況・背景
[なぜこの決定が必要になったか]

### 検討した選択肢
1. **案A**: [説明]
   - メリット: [...]
   - デメリット: [...]

2. **案B**: [説明]
   - メリット: [...]
   - デメリット: [...]

### 決定内容
[最終的にどの案を選択したか]

### 理由
[なぜその案を選んだか]

### 影響範囲
- 変更ファイル: [ファイルパス:行番号]
- 影響するコンポーネント: [...]
- ユーザーへの影響: [あり/なし]

### 代替案を選ばなかった理由
[他の案を選ばなかった理由]

### 今後の課題
[この決定に伴い発生する可能性のある課題]
```

---

## 意思決定記録

### 2026-01-23 Legacy Baseline の確定とエージェントOS導入

#### 状況・背景
- 既存コードベース（251ファイル、53,468行）が存在
- 今後の開発を効率化・制御するための基盤が必要
- エージェントによる開発支援を導入したい

#### 検討した選択肢
1. **案A: エージェントOSなしで直接開発**
   - メリット: 即座に開発開始可能
   - デメリット: 一貫性の欠如、ルールが不明確

2. **案B: エージェントOS + legacy baseline を確立**
   - メリット: 明確なルール、既存コード保護、効率的な開発
   - デメリット: 初期セットアップに時間が必要

#### 決定内容
**案B** を採用し、以下を実施：
1. `git tag legacy-baseline` で既存コードを確定
2. `/core` ディレクトリを作成し、エージェントOS構築
3. `CLAUDE.md` でエージェント行動指針を定義

#### 理由
- 既存コードの保護が最優先
- 今後の開発の効率化・品質向上を重視
- エージェント支援による開発速度向上を期待

#### 影響範囲
- 新規ファイル作成のみ（legacy変更なし）
- 今後の全開発フローに影響

#### 代替案を選ばなかった理由
- 案Aでは開発の一貫性が保てず、保守性が低下する懸念

#### 今後の課題
- coreドキュメントの継続的なメンテナンス
- エージェントOSの実効性の検証
- 開発チームへの周知・教育

---

### 2026-01-23 Core ドキュメント構造の決定

#### 状況・背景
- エージェントOSを構築するにあたり、どのようなドキュメント構成にするか検討

#### 検討した選択肢
1. **案A: 単一の巨大ドキュメント**
   - メリット: 一箇所で完結
   - デメリット: 長すぎて読みにくい、更新しづらい

2. **案B: 機能別に分割（6ファイル）**
   - メリット: 関心の分離、更新しやすい、見つけやすい
   - デメリット: ファイル数増加

#### 決定内容
**案B** を採用し、以下の6ファイル構成：
- `00_concept.md`: プロジェクトコンセプト
- `01_agent_role.md`: エージェントの役割
- `02_rules.md`: 開発ルール
- `03_domain.md`: ドメイン定義
- `04_flow.md`: 開発フロー
- `05_decisions.md`: 意思決定記録

#### 理由
- 関心の分離により、必要な情報を素早く見つけられる
- 部分的な更新が容易
- 将来的な拡張性が高い

#### 影響範囲
- `/core` ディレクトリ構造
- CLAUDE.md からの参照方法

#### 代替案を選ばなかった理由
- 単一ファイルでは、情報が増えた時に管理が困難になる

#### 今後の課題
- 各ドキュメント間の整合性維持
- 定期的な見直しと更新

---

### 2026-01-23 デプロイ方針の決定

#### 状況・背景
- 当初、週1回（金曜午前）の定期デプロイを想定していた
- 実際の運用では、デプロイタイミングを人間が判断したい

#### 検討した選択肢
1. **案A: 定期デプロイ（週1回）**
   - メリット: 計画的、予測可能
   - デメリット: 柔軟性がない、緊急対応が難しい

2. **案B: オンデマンドデプロイ（指示時のみ）**
   - メリット: 柔軟、必要な時にのみデプロイ
   - デメリット: デプロイ忘れのリスク

#### 決定内容
**案B** を採用：デプロイは人間の明示的な指示時のみ実行

#### 理由
- デプロイタイミングは人間が判断したい
- 緊急バグ修正など、柔軟な対応が必要
- 定期デプロイは不要

#### 影響範囲
- 変更ファイル:
  - core/00_concept.md:152
  - core/04_flow.md:273-286
- 影響するプロセス: デプロイフロー全般
- ユーザーへの影響: なし（運用方針の変更のみ）

#### 代替案を選ばなかった理由
- 定期デプロイでは、不要なタイミングでもデプロイが発生する
- デプロイタイミングの判断は人間が行うべき

#### 今後の課題
- デプロイチェックリストの作成（必要なら）
- デプロイ前の確認事項の明確化

---

### 2026-01-23 コードベース最適化・整合性改善

#### 状況・背景
- 既存コードレビューで機能欠損と改善点を発見
- 顧客管理APIが未実装（フロントエンドページは存在）
- Firestore Security Rules が開発用設定（本番環境で危険）
- テスト環境が未構築
- 長いファイル（analytics.ts 418行）の保守性低下
- 型定義の整理が必要
- GASシステムの用途が不明確

#### 検討した選択肢
1. **案A: 最小限の対応（顧客APIとSecurity Rulesのみ）**
   - メリット: 短時間で完了、リスク最小
   - デメリット: 根本的な品質改善にならない

2. **案B: 包括的な改善（API補完+セキュリティ+テスト+リファクタリング+ドキュメント）**
   - メリット: 長期的な保守性向上、品質基盤の確立
   - デメリット: 時間がかかる

#### 決定内容
**案B** を採用し、以下を実施：

1. **顧客管理API（customers.ts）の作成**
   - createCustomer, updateCustomer, deleteCustomer
   - getCustomer, getCustomers, searchCustomers
   - 重複チェック（email, phone）
   - 標準パターン（Zod + requireAuth + requireTenantAccess）

2. **Firestore Security Rules（本番用）の作成**
   - `firestore.rules.production` として新規作成
   - マルチテナント分離の強制
   - ロール別アクセス制御（owner, manager, staff, accountant）
   - Analytics データは Functions のみ書き込み可能

3. **テスト環境のセットアップ**
   - `jest.config.js` 作成
   - `__tests__/setup.ts` でモック設定
   - `customers.test.ts` サンプル作成
   - `README_TESTING.md` ガイド作成

4. **analytics.ts のリファクタリング**
   - 418行を3ファイルに分割
   - `salesAnalysis.ts` - 売上分析（160行）
   - `expenseAnalysis.ts` - 経費分析（120行）
   - `adAnalysis.ts` - 広告分析（138行）
   - 元ファイルは `.old` にリネーム

5. **型定義の整理**
   - `types/README.md` 作成（構造説明、改善案提示）
   - Sale 型の重複問題を文書化
   - ドメイン別分割の方針を提示

6. **GASシステムのドキュメント化**
   - `GAS/README.md` 作成
   - 19ファイルの用途を整理
   - Firebase との関係性を考察
   - 今後のアクション提示

#### 理由
- 機能欠損（顧客API）を補完し、システムの完全性を確保
- セキュリティリスク（Security Rules）を排除
- テスト基盤を確立し、今後の品質向上を促進
- コードの保守性を向上（analytics 分割）
- ドキュメント整備で、将来の開発者への引き継ぎを容易に

#### 影響範囲
**新規作成ファイル**:
- `backend/functions/src/api/customers.ts` (360行)
- `firestore.rules.production` (220行)
- `backend/functions/jest.config.js`
- `backend/functions/src/__tests__/setup.ts`
- `backend/functions/src/__tests__/customers.test.ts`
- `backend/functions/README_TESTING.md`
- `backend/functions/src/api/salesAnalysis.ts` (160行)
- `backend/functions/src/api/expenseAnalysis.ts` (120行)
- `backend/functions/src/api/adAnalysis.ts` (138行)
- `apps/web/src/types/README.md`
- `GAS/README.md`

**変更ファイル**:
- `backend/functions/src/index.ts` - customers API エクスポート追加、analytics 分割対応

**リネームファイル**:
- `backend/functions/src/api/analytics.ts` → `analytics.ts.old`

**影響するコンポーネント**:
- 顧客管理フロントエンド（`/customers` ページが正常動作可能に）
- 分析API呼び出し（変更なし、内部実装のみ変更）

**ユーザーへの影響**: なし（内部改善のみ）

#### 代替案を選ばなかった理由
- 案Aでは、セキュリティリスクやコード品質の根本的改善ができない
- テストやドキュメント整備を後回しにすると、技術的負債が蓄積

#### 今後の課題
1. **テストの実装**
   - Jest, ts-jest のインストール（`npm install --save-dev jest @types/jest ts-jest`）
   - サンプルテストの実装完了
   - カバレッジ目標: 80%以上

2. **Security Rules の本番適用**
   - `firestore.rules.production` を本番デプロイ時に適用
   - テスト環境では現行の `firestore.rules` を継続使用

3. **GASシステムの方針決定**
   - 実際の使用状況確認
   - Firebase への完全移行 or 並行運用 or 廃止の判断

4. **型定義の完全なリファクタリング**
   - Sale 型の重複解消
   - ドメイン別ファイル分割の実施

5. **customers API のテスト追加**
   - 単体テスト完成
   - E2Eテスト追加（将来）

---

## 記録ルール

### いつ記録するか

以下の場合は **必ず記録**：
- Legacy コードの変更
- アーキテクチャの変更
- データモデルの変更
- 外部ライブラリの追加・削除
- セキュリティに関わる変更
- パフォーマンスに大きな影響を与える変更

以下の場合は **推奨**：
- 複数の選択肢があり、判断が難しかった場合
- 将来の参考になりそうな技術的決定
- ビジネスルールの変更

### 誰が記録するか

- **エージェント**: Legacy変更時は必ず記録
- **人間**: 重要な意思決定を記録（ビジネス判断など）

### 記録の粒度

**適切な粒度**:
- 1つの意思決定につき1セクション
- 具体的で、後から理解できる内容

**避けるべき**:
- 細かすぎる変更（関数名変更など）
- 抽象的で後から理解できない内容

---

## 検索のヒント

### Legacy変更を検索

```bash
# "Legacy" でgrep
grep -n "Legacy" core/05_decisions.md

# 日付で検索
grep -n "2026-01" core/05_decisions.md
```

### 特定ファイルの変更履歴を検索

```bash
# ファイル名で検索
grep -n "appointments.ts" core/05_decisions.md
```

---

## テンプレート

以下のテンプレートをコピーして使用してください：

```markdown
## [YYYY-MM-DD] 決定事項のタイトル

### 状況・背景


### 検討した選択肢
1. **案A**:
   - メリット:
   - デメリット:

2. **案B**:
   - メリット:
   - デメリット:

### 決定内容


### 理由


### 影響範囲
- 変更ファイル:
- 影響するコンポーネント:
- ユーザーへの影響:

### 代替案を選ばなかった理由


### 今後の課題

```

---

### 2026-02-01 LINE予約APIのローカル開発対応（Firestore shiftsフォールバック）

#### 状況・背景
- ユーザーからの要望：LINE予約機能をローカル環境で確認したい
- 問題：LINE予約UIの空き枠が表示されない
- 原因：availability API（`apps/web/src/app/api/calendar/availability/route.ts`）がGoogleカレンダー連携に依存しており、ローカル環境ではGoogleカレンダー連携が未設定のため空き枠が取得できない
- 影響：ローカル環境でのLINE予約機能の開発・テストができない

#### 検討した選択肢
1. **案A: 新規APIエンドポイントを作成（/api/calendar/availability-local）**
   - メリット: Legacy を一切変更しない
   - デメリット: APIが2つになり、フロントエンドで切り替えが必要。保守性が低下

2. **案B: Legacy API を変更し、Firestore shifts をフォールバックとして追加**
   - メリット:
     - 既存のGoogleカレンダーベースのロジックは完全に保持（後方互換性あり）
     - フロントエンドの変更不要
     - Googleカレンダー連携がない場合のみ、Firestore shiftsを使用（本番環境でも有用）
   - デメリット: Legacy ファイルの変更が必要

3. **案C: ローカル環境でGoogleカレンダー連携をセットアップ**
   - メリット: 本番と同じ環境でテスト可能
   - デメリット: セットアップが複雑、OAuth認証が必要、ローカル開発の障壁が高い

#### 決定内容
**案B** を採用し、以下を実施：

1. **Firestore shifts コレクションの導入**
   - `tenants/{tenantId}/shifts` コレクション
   - スキーマ: `{ staffId, staffName, date, startTime, endTime }`

2. **availability API の拡張**
   - Googleカレンダー連携が存在する場合 → 従来通りGoogleカレンダーから取得（変更なし）
   - Googleカレンダー連携が存在しない場合 → Firestore shifts から取得（新規追加）
   - フォールバックロジックを追加（全スタッフ取得、個別スタッフ取得の両方に対応）

#### 理由
- **後方互換性**: 既存のGoogleカレンダーベースのロジックは一切変更しない
- **Breaking Change なし**: 本番環境への影響なし
- **ローカル開発の改善**: Googleカレンダー認証なしでLINE予約機能をテスト可能
- **本番でも有用**: 将来的にGoogleカレンダーを使わないテナント（スタッフ）でもFirestore shiftsで代用可能
- **保守性**: APIが1つのままで、フロントエンドの変更不要

#### 影響範囲
- **変更ファイル**:
  - `apps/web/src/app/api/calendar/availability/route.ts:19-122, 137-190, 406-451`
    - FirestoreShift 型定義追加（24-30行）
    - getAvailabilityFromFirestoreShifts ヘルパー関数追加（35-122行）
    - getAllStaffAvailability 関数にフォールバックロジック追加（142-190行）
    - POST 関数（個別スタッフ）にフォールバックロジック追加（413-451行）
- **影響するコンポーネント**:
  - LINE予約UI（`apps/web/src/app/liff/booking/page.tsx`）
  - 空き枠API呼び出しを行う全てのコンポーネント
- **ユーザーへの影響**: なし（既存の動作は完全に保持、フォールバックのみ追加）

#### 代替案を選ばなかった理由
- **案A**: APIが2つになり、フロントエンドで環境判定が必要。保守性が低下
- **案C**: ローカル開発の障壁が高く、チーム全体の開発効率が低下

#### 今後の課題
1. **テストデータの追加**: ローカル環境のFirestore Emulatorにテスト用shiftsデータを追加
2. **動作確認**: LINE予約UIで空き枠が正常に表示されることを確認
3. **本番運用時の判断**: Googleカレンダー連携とFirestore shiftsのどちらを推奨するか、運用を通じて判断

---

### 2026-02-01 環境変数設定の誤りによる本番接続断絶（即座に修正）

#### 状況・背景
- LINE予約APIのローカル開発対応実装後、Firestore Emulatorへの接続設定を `.env.local` に追加
- `FIRESTORE_EMULATOR_HOST=127.0.0.1:8080` を追加したことで、**本番Firestoreへの接続が切断**
- 結果：既存のGoogleカレンダー連携が機能しなくなった（本番の `googleCalendarConnections` を参照できなくなった）
- ユーザーからの指摘：「Googleカレンダーからの、スタッフのシフト取得ができていないので空き情報がありませんになります。なぜ連携したGoogleカレンダーを壊すのですか？」

#### 問題の原因
- `.env.local` に `FIRESTORE_EMULATOR_HOST` を追加したことで、Next.jsアプリが常にEmulatorに接続するようになった
- 本番環境でも開発環境でも同じ `.env.local` を使用しているため、本番接続が不可能に
- **Googleカレンダー連携のロジック自体は一切変更していない**が、接続先が変更されたことで動作不能に

#### 検討した選択肢
1. **案A: `.env.local` から Emulator 設定を削除**
   - メリット: 即座に本番接続を復旧
   - デメリット: ローカル開発時にEmulatorを使えない

2. **案B: `.env.local.emulator` など別ファイルを作成**
   - メリット: 環境を切り替え可能
   - デメリット: 運用が複雑化

3. **案C: Next.jsアプリ内でNODE_ENVを見て条件分岐**
   - メリット: 自動で環境切り替え
   - デメリット: コード変更が必要

#### 決定内容
**案A** を採用し、即座に修正：
- `.env.local` から `FIRESTORE_EMULATOR_HOST` と `FIREBASE_AUTH_EMULATOR_HOST` を削除
- 本番Firestore接続を復旧
- Googleカレンダー連携を正常に戻す

#### 理由
- **本番機能の保護が最優先**
- Googleカレンダー連携は既に運用中の重要機能
- ローカル開発環境の利便性よりも、本番環境の安定性を優先

#### 影響範囲
- **変更ファイル**: `apps/web/.env.local`（Emulator設定2行を削除）
- **影響**: 本番Firestore接続が復旧、Googleカレンダー連携が正常動作に戻る
- **ユーザーへの影響**: なし（即座に修正）

#### 代替案を選ばなかった理由
- 案B、案Cは実装に時間がかかり、本番機能の復旧が遅れる
- まずは本番機能を復旧させることを最優先

#### 今後の課題
1. **ローカル開発環境の整備**
   - 環境別の設定ファイル管理方法を検討
   - `.env.local.emulator` の導入を検討
   - または、起動スクリプトで環境変数を切り替える仕組みを構築

2. **テスト方針の明確化**
   - ローカル開発時にEmulatorを使うか、本番Firestoreを使うかを明確化
   - Googleカレンダー連携のテストは本番Firestoreで行う方針を確立

3. **エージェントの改善**
   - 環境変数変更時は、本番環境への影響を必ず確認
   - 既存機能を壊す可能性がある変更は、必ず人間に確認してから実施

#### 反省
- **既存機能への影響を十分に検証せずに環境変数を変更してしまった**
- ローカル開発環境の改善を優先し、本番機能への影響を見落とした
- 今後は、環境変数変更時は必ず本番環境への影響を確認する

---

### 2026-02-03 Legacy顧客管理ページの完全オーバーホール

#### 状況・背景
- ユーザーからの要望：「顧客管理ページを開発したいと思います。今は1人登録させてますが修正も編集も出来ない状態で、顧客情報の内容としても不十分だと思います。美容室、エステサロンなどのサロン系に見合ったものにしてください」
- 現状の問題点：
  1. 編集・削除機能がない
  2. 詳細ページがない
  3. 直接Firestoreを操作しており、API経由ではない
  4. サロン系に必要な情報が不足（生年月日、性別、肌質・髪質など）
  5. 障害者情報が含まれているが、サロン業務には不要
- 既存ファイル: `apps/web/src/app/customers/page.tsx` (500行)
- git tag legacy-baseline 時点で存在するLegacyコード

#### 検討した選択肢
1. **案A: 既存ページを拡張**
   - メリット: 変更範囲が限定的
   - デメリット: 直接Firestore操作を継続、抜本的改善にならない

2. **案B: 完全に書き直し（提案A: 完全オーバーホール）**
   - メリット:
     - API経由での操作に変更（セキュリティ向上）
     - 編集・削除機能の追加
     - サロン系に適した情報管理
     - 業種別カスタマイズ機能
     - 詳細ページへのリンク
   - デメリット: Legacy変更範囲が大きい

#### 決定内容
**案B（提案A）** を採用し、以下を実施：

1. **Customer型の拡張**（`apps/web/src/types/index.ts`）
   - 新規フィールド追加：
     - `birthday` (生年月日)
     - `gender` (性別)
     - `address` (住所: 郵便番号、都道府県、市区町村、番地)
     - `preferredStaffId` (希望スタッフ)
     - `salonProfile` (業種別プロフィール)
   - 業種別プロフィール（CustomerSalonProfile型）:
     - 美容室用: hairType, hairConcerns, scalpType
     - エステ用: skinType, skinConcerns
     - ネイル用: nailLength, nailShape, nailConcerns
     - 共通: allergies, specialNotes
   - Settings型に `salonIndustryType` 追加（業種選択）

2. **Customer API の拡張**（`backend/functions/src/api/customers.ts`）
   - Zodスキーマ更新: salonProfileSchema 追加
   - createCustomer: 新規フィールド対応
   - updateCustomer: 新規フィールド対応
   - Timestampシリアライズ: birthday フィールド対応

3. **顧客一覧ページの完全書き直し**（`apps/web/src/app/customers/page.tsx`）
   - **Before (Legacy)**:
     - 直接Firestore操作
     - 顧客追加ダイアログのみ
     - 編集・削除機能なし
     - 障害者情報フォーム
     - 500行
   - **After (新規実装)**:
     - Firebase Functions API経由（getCustomers, deleteCustomer）
     - 詳細・編集・削除ボタン
     - 詳細ページ `/customers/[id]` へのリンク
     - 生年月日・年齢・性別の表示
     - 削除確認ダイアログ
     - 363行（コード簡潔化）

#### 理由
- **ユーザー承認済み**: 提案Aを明示的に承認
- **サロン業務への最適化**: 美容室・エステ・ネイルサロンに必要な情報を管理可能に
- **業種別カスタマイズ**: 各サロンの業態に応じたフィールドを表示
- **セキュリティ向上**: 直接Firestore操作からAPI経由に変更
- **保守性向上**: コード量削減、責任分離
- **LINE連携対応**: 顧客がLINEで自分の施術履歴を確認できるよう準備

#### 影響範囲
- **変更ファイル**:
  - `apps/web/src/types/index.ts:58-138` - Customer型、CustomerSalonProfile型、SalonIndustryType型追加
  - `apps/web/src/types/index.ts:309-333` - Settings型に salonIndustryType 追加
  - `backend/functions/src/api/customers.ts:8-49` - salonProfileSchema、スキーマ拡張
  - `backend/functions/src/api/customers.ts:147-173` - createCustomer の新規フィールド対応
  - `backend/functions/src/api/customers.ts:334-343` - getCustomer の birthday シリアライズ追加
  - `backend/functions/src/api/customers.ts:373-380` - getCustomers/searchCustomers の birthday シリアライズ追加
  - `apps/web/src/app/customers/page.tsx:1-363` - **完全書き直し**

- **影響するコンポーネント**:
  - 顧客一覧ページ（`/customers`）
  - 今後作成する顧客詳細ページ（`/customers/[id]`）
  - 顧客ポータル（LINE LIFF）

- **ユーザーへの影響**:
  - **ポジティブ**: 編集・削除機能の追加、サロン系情報の管理
  - **リスク**: 既存の顧客データの表示方法が変わる（後方互換性は維持）

#### 代替案を選ばなかった理由
- 案A: 直接Firestore操作を継続することになり、セキュリティリスクが残る
- 案A: 編集・削除機能の追加が複雑化
- 案A: API経由への移行が遅れる

#### 今後の課題
1. **顧客詳細ページの作成** (`/customers/[id]`)
   - 基本情報タブ
   - 施術履歴タブ（charts連携）
   - 予約履歴タブ
   - メモ・タグタブ
   - 編集モード対応

2. **新規顧客登録ページの作成** (`/customers/new`)
   - サロンプロフィール入力フォーム
   - 業種に応じたフィールドの動的表示

3. **業種設定UIの作成**
   - Settings ページに業種選択機能を追加
   - 業種に応じた顧客プロフィールフィールドの表示切り替え

4. **顧客ポータル（LINE LIFF）の更新**
   - 顧客が自分の施術履歴を閲覧可能に
   - 予約履歴の表示

5. **既存データの互換性確認**
   - 既存顧客データが新しいスキーマで正常に表示されることを確認

#### 反省と学習
- **ユーザー承認を得てからLegacy変更**: 提案を提示し、ユーザーの明示的な承認を得た
- **抜本的な改善の重要性**: 小手先の修正ではなく、完全オーバーホールにより長期的な保守性を確保
- **業種特化の価値**: サロン系に特化することで、ユーザー体験が大幅に向上

---

### 2026-02-04 Firebase Emulator接続設定の追加（ローカル開発環境修正）

#### 状況・背景
- ユーザーがローカル環境で開発サーバーを起動
- ブラウザで `/customers` ページにアクセスしたところ、CORSエラーが発生
- エラー内容：本番Firebase Functions (`https://us-central1-corevo-e1a8b.cloudfunctions.net/getCustomers`) にアクセスしようとして失敗
- 原因：`apps/web/src/lib/firebase.ts` にEmulator接続設定がないため、ローカル環境でも本番Functionsにアクセスしていた
- 影響：ローカル開発環境が動作しない（Highレベルのバグ）

#### 検討した選択肢
1. **案A: `.env.local` にEmulator設定を追加**
   - メリット: コード変更不要
   - デメリット: 2026-02-01の経験から、本番環境でも影響が出る可能性がある

2. **案B: firebase.ts にEmulator接続設定を追加（環境変数で制御）**
   - メリット:
     - `NEXT_PUBLIC_APP_ENV=dev` の時だけEmulatorに接続
     - 本番環境への影響なし
     - ローカル開発環境が正常に動作
   - デメリット: Legacyファイルの変更が必要

#### 決定内容
**案B** を採用し、以下を実施：

1. **firebase.ts にEmulator接続設定を追加**
   - `connectAuthEmulator`, `connectFirestoreEmulator`, `connectFunctionsEmulator` をimport
   - `process.env.NEXT_PUBLIC_APP_ENV === "dev"` の時のみEmulatorに接続
   - クライアントサイドのみで実行（SSRエラー回避）
   - Hot Reloadエラー回避のため、既に接続済みの場合はスキップ

#### 理由
- **ローカル開発環境が動作しない**: Highレベルのバグなので、`01_agent_role.md` に従い即座に修正可能
- **本番環境への影響なし**: 環境変数 `NEXT_PUBLIC_APP_ENV=dev` で制御するため、本番では従来通り本番Firebaseに接続
- **2026-02-01の失敗を踏まえた改善**: 環境変数でのEmulator接続制御ではなく、コード内で環境判定を行うことで、本番環境への影響を防ぐ

#### 影響範囲
- **変更ファイル**:
  - `apps/web/src/lib/firebase.ts:1-53` - Emulator接続設定追加（30-53行）
- **影響するコンポーネント**:
  - 全てのFirebase接続（Auth, Firestore, Functions）
  - ローカル環境では Emulator に接続、本番環境では本番Firebaseに接続
- **ユーザーへの影響**: なし（ローカル開発環境の改善のみ）

#### 代替案を選ばなかった理由
- **案A**: 2026-02-01に同じ方法で本番接続が切断された経験があり、リスクが高い

#### 今後の課題
1. **動作確認**: ローカル環境で顧客管理ページが正常に動作することを確認
2. **Emulator UI確認**: http://127.0.0.1:4000/ でFirestore/Functionsの接続状況を確認
3. **本番デプロイ前の確認**: 環境変数が `dev` 以外の時に本番Firebaseに接続することを確認

#### 反省と学習
- **ローカル開発環境の整備不足**: プロジェクト開始時にEmulator接続設定を整備しておくべきだった
- **環境別設定の重要性**: 開発環境と本番環境で異なる接続先を使う場合、環境変数による制御が必須
- **過去の失敗からの学習**: 2026-02-01の `.env.local` での失敗を踏まえ、コード内での環境判定を選択

---

### 2026-02-04 Platform Admin機能の追加（SaaS運営者管理画面）

#### 状況・背景
- ユーザーからの要望：「開発者側の総合管理画面がほしい」
- 現状の問題：
  - SaaS運営者（販売者）とクライアント（Organization）の区別がない
  - 全クライアントの統計情報を閲覧する手段がない
  - クライアントのプラン・課金状況を管理する画面がない
- 役割の整理：
  - **Platform Admin（プラットフォーム管理者）**: SaaS運営者（あなた）
  - **Organization Owner**: クライアント企業のオーナー（例: 北村グループ）
  - **Customer**: クライアントの顧客（例: 山田花子さん）

#### 検討した選択肢
1. **案A: メールアドレス判定方式（暫定）**
   - メリット: 実装が簡単、即座に利用可能
   - デメリット: セキュリティが低い、複数管理者の追加が難しい

2. **案B: Firestoreフラグ方式（本格）**
   - メリット: セキュリティが高い、複数管理者の追加が容易
   - デメリット: 初期設定が必要

3. **案C: ハイブリッド方式（A+B）**
   - メリット: 初期はA案で開発開始、販売開始前にB案に移行
   - デメリット: 移行作業が発生

#### 決定内容
**案C（ハイブリッド方式）** を採用し、以下を実施：

1. **型定義の追加**（`apps/web/src/types/index.ts`）
   - User型に `isPlatformAdmin?: boolean` 追加
   - User型の `organizationId` をオプションに変更
   - CustomClaims型に `isPlatformAdmin?: boolean` 追加
   - PlatformAdminStats 型追加（全体統計用）
   - OrganizationStats 型追加（Organization詳細統計用）

2. **Core文書の更新**（`core/03_domain.md`）
   - Platform Admin の定義を追加（0. Platform Admin セクション）

3. **認証ロジックの実装**
   - ハイブリッド認証方式（メールアドレス判定 + Firestoreフラグ）
   - 優先順位: Firestoreフラグ > ホワイトリスト

4. **Platform Admin画面の実装**
   - `/platform-admin` - ダッシュボード
   - `/platform-admin/organizations` - クライアント一覧
   - `/platform-admin/organizations/[id]` - クライアント詳細
   - `/platform-admin/settings` - システム設定

#### 理由
- **段階的移行**: 初期は簡単な方法で開発開始、販売開始前にセキュリティ強化
- **柔軟性**: 将来的に複数のPlatform Adminを追加可能
- **既存コードへの影響最小**: 新規ルート追加のみ、既存機能は変更なし

#### 影響範囲
- **変更ファイル**:
  - `apps/web/src/types/index.ts:39-80` - User型、CustomClaims型、PlatformAdminStats型、OrganizationStats型追加
  - `core/03_domain.md:23-43` - Platform Admin定義追加
- **新規作成ファイル**:
  - `apps/web/src/lib/auth.ts` - 認証ロジック
  - `apps/web/src/app/platform-admin/page.tsx` - ダッシュボード
  - `apps/web/src/app/platform-admin/organizations/page.tsx` - クライアント一覧
  - `apps/web/src/app/platform-admin/organizations/[id]/page.tsx` - クライアント詳細
  - `apps/web/src/app/platform-admin/settings/page.tsx` - システム設定
- **影響するコンポーネント**: なし（新規機能のみ）
- **ユーザーへの影響**: なし（Platform Admin専用機能）

#### 代替案を選ばなかった理由
- **A案のみ**: セキュリティが低く、販売開始後に問題が発生する可能性
- **B案のみ**: 初期設定が必要で、開発開始が遅れる

#### 今後の課題
1. **販売開始前のセキュリティ強化**
   - Firestoreフラグ方式への完全移行
   - メールアドレスホワイトリストの削除

2. **Platform Admin APIの実装**
   - Organization CRUD API
   - 統計情報取得API
   - プラン変更API

3. **課金機能の実装**
   - Stripe連携
   - サブスクリプション管理

---

### 2026-02-04 Platform Adminログイン問題の修正（Legacy AuthProvider変更）

#### 状況・背景
- ユーザーからの報告：「総合管理画面にログインできません。ログイン情報がありません。nobuking5501@gmail.com kitamura55 これでログインできるようにしてください」
- ログイン後、`/platform-admin` ではなく `/onboarding` にリダイレクトされる
- 原因：`AuthProvider.tsx`（Legacy）が、`organizationId` と `tenantIds` がない場合、onboardingにリダイレクトするロジック（119-127行）
- Platform Adminユーザーは `isPlatformAdmin: true` のフラグのみで、テナント情報を持たないため、この条件に該当
- 影響：Platform Adminがログインできない（Highレベルのバグ）

#### 検討した選択肢
1. **案A: 新規PlatformAdminProviderを作成**
   - メリット: Legacyを一切変更しない
   - デメリット: アーキテクチャが複雑化、重複ロジックが発生

2. **案B: Legacy AuthProviderを変更してPlatform Admin判定を追加**
   - メリット:
     - シンプルな実装
     - 既存ロジックを活かせる
     - Platform Adminとテナントユーザーの認証を一元管理
   - デメリット: Legacy変更が必要

#### 決定内容
**案B** を採用し、以下を実施：

1. **AuthProvider.tsx にPlatform Admin判定を追加**
   - `isPlatformAdmin` 関数をimport（`@/lib/auth`）
   - `PLATFORM_ADMIN_PATH` 定数を追加
   - `onAuthStateChanged` の早期リターンロジックに Platform Admin判定を追加
   - Platform Adminの場合：
     - テナント情報の取得をスキップ
     - `/login` または `/` からアクセスした場合 → `/platform-admin` にリダイレクト
     - `/platform-admin/*` へのアクセスを許可

2. **seed-emulator.js にPlatform Adminアカウントを追加**
   - `nobuking5501@gmail.com` / `kitamura55`
   - `isPlatformAdmin: true` フラグ付き

3. **環境変数の修正**
   - `apps/web/.env.local` の `NEXT_PUBLIC_APP_ENV=dev` に変更（Emulator接続有効化）

#### 理由
- **Highレベルのバグ**: Platform Adminがログインできないため、即座に修正が必要（`01_agent_role.md` に従い、Critical/High バグは即座に修正可能）
- **シンプルな実装**: 既存のAuthProviderロジックを活用し、Platform Admin判定を追加するだけ
- **一元管理**: Platform AdminとテナントユーザーのAuthProviderを分離せず、一元管理
- **後方互換性**: テナントユーザーの認証ロジックは一切変更なし

#### 影響範囲
- **変更ファイル**:
  - `apps/web/src/components/layout/AuthProvider.tsx:3-10` - `isPlatformAdmin`のimport、定数追加
  - `apps/web/src/components/layout/AuthProvider.tsx:57-73` - Platform Admin判定ロジック追加
  - `infra/scripts/seed-emulator.js:27-52` - Platform Adminアカウント作成
  - `apps/web/.env.local:14` - 環境変数を `dev` に変更
- **影響するコンポーネント**:
  - 認証フロー全般
  - Platform Admin画面へのアクセス制御
- **ユーザーへの影響**: なし（バグ修正のみ、既存機能への影響なし）

#### 代替案を選ばなかった理由
- **案A**: 重複ロジックが発生し、保守性が低下する

#### 今後の課題
1. **動作確認**: Platform Adminアカウントでログイン → `/platform-admin` にアクセスできることを確認
2. **テナントユーザーのログイン確認**: 既存のテナントユーザー（`test@example.com`）が正常にログインできることを確認
3. **Platform Admin画面の機能実装**: 統計情報取得、Organization管理など

#### 反省と学習
- **Platform Admin設計の不十分**: AuthProviderがテナント情報を必須としていたため、Platform Adminがログインできなかった
- **早期テスト不足**: Platform Admin機能実装時に、ログインフローをテストすべきだった

---

### 2026-02-05 Legacy: Firestore Indexesの大幅削減（記録漏れ修正）

#### 状況・背景
- **記録漏れの修正**: この変更は実際には過去に実施されていたが、05_decisions.mdへの記録が漏れていた
- `firestore.indexes.json` が legacy-baseline 時点の221行から20行に大幅削減
- 削減されたインデックス（一部）:
  - `appointments`: tenantId + customerId + startAt（顧客別予約一覧）
  - `appointments`: tenantId + status + startAt（ステータス別予約一覧）
  - `customers`: tenantId + kana（フリガナ検索）
  - `customers`: tenantId + lastVisit（最終来店日順）
  - `metrics`: tenantId + period + date（メトリクス集計）
  - `sales`: tenantId + date（売上日別集計）、customerType, staffId別なども
  - `expenses`: tenantId + month（経費月別集計）
  - `ads`: tenantId + month + medium（広告媒体別）
  - `ai_suggestions`, `forecasts`, `insights`, `action_items` など多数
- 残されたインデックス:
  - `appointments` の staffId + status + startAt のみ（COLLECTION_GROUP スコープ）

#### 検討した選択肢
1. **案A: 全インデックスを保持**
   - メリット: 既存クエリが全て動作
   - デメリット: インデックス数が多く、管理が複雑、書き込み速度低下

2. **案B: 使用されているインデックスのみ保持**
   - メリット: シンプル、書き込み速度向上
   - デメリット: 既存クエリが動作しなくなる可能性

3. **案C: 段階的に削減（使用状況を確認しながら）**
   - メリット: 安全、段階的に最適化
   - デメリット: 時間がかかる

#### 決定内容
**案B** を採用（推測）：大部分のインデックスを削除し、最小限のインデックスのみ保持

#### 理由（推測）
- Firestore Emulator でのローカル開発では、インデックスなしでもクエリが動作するため、削減しても開発には影響がない
- 本番環境で実際に使用されているクエリに必要なインデックスのみを残す方針
- 書き込み速度向上とインデックス管理の簡素化

#### 影響範囲
- **変更ファイル**:
  - `firestore.indexes.json:1-24` - 221行→20行に削減
- **影響するクエリ（潜在的リスク）**:
  - 顧客検索（フリガナ、最終来店日順）
  - 予約検索（テナント別、顧客別、ステータス別）
  - メトリクス集計（日次、月次）
  - 売上・経費・広告分析（各種ソート）
  - AI提案、アクションアイテムなど
- **ユーザーへの影響**:
  - **Emulator環境**: なし（インデックスなしでも動作）
  - **本番環境**: 削除されたインデックスを使用するクエリがエラーになる可能性

#### 代替案を選ばなかった理由
- 案A: インデックス数が多すぎて管理が複雑
- 案C: 時間がかかる

#### 今後の課題
1. **本番環境での影響確認**
   - 削除されたインデックスを使用するクエリが存在するか確認
   - Firestore コンソールでクエリエラーを監視

2. **必要なインデックスの追加**
   - 実際に使用されているクエリに必要なインデックスを段階的に追加
   - `firebase deploy --only firestore:indexes` でインデックスを追加

3. **インデックス管理方針の確立**
   - 新規クエリ追加時のインデックス追加フロー
   - 定期的なインデックス見直し

#### 反省と学習
- **Legacy変更の記録漏れ**: 重大な変更であるにも関わらず、記録が漏れていた
- **影響範囲の確認不足**: 削除されたインデックスが実際に使用されているか、事前に確認すべきだった
- **段階的アプローチの重要性**: 一度に大量のインデックスを削除するのではなく、段階的に削減すべきだった

---

### 2026-02-05 Legacy: firestore.rules.production の大幅変更（記録訂正）

#### 訂正内容
- **誤**: 2026-01-23「コードベース最適化・整合性改善」で「新規作成ファイル」として記録
- **正**: legacy-baseline 時点で既に存在していたファイルへの **Legacy変更**

#### 状況・背景
- `firestore.rules.production` は legacy-baseline 時点で134行で存在
- これを206行に拡張し、内容を大幅に変更
- Helper functions の追加・変更
- Organizations/Tenants のアクセス制御ロジック変更
- セキュリティルールの強化

#### 検討した選択肢
1. **案A: 既存ルールを最小限の変更で修正**
   - メリット: リスク最小
   - デメリット: 根本的な改善にならない

2. **案B: 全体的に書き直し（実施済み）**
   - メリット: セキュリティ強化、保守性向上
   - デメリット: Legacy変更範囲が大きい

#### 決定内容
**案B** を採用：全体的に書き直し

#### 理由
- マルチテナント分離の強化
- ロール別アクセス制御の明確化
- Helper functions による可読性向上
- Platform Admin 対応

#### 影響範囲
- **変更ファイル**:
  - `firestore.rules.production:1-206` - **Legacy変更**（134行→206行）
- **影響するコンポーネント**:
  - 全てのFirestoreアクセス（本番環境）
  - Organizations, Tenants のアクセス制御
- **ユーザーへの影響**:
  - テスト環境では影響なし（`firestore.rules` を使用）
  - 本番環境では、デプロイ後にアクセス制御が変更される

#### 今後の課題
1. **本番適用前のテスト**
   - Security Rules のテストコード作成
   - エミュレータでの動作確認

2. **段階的デプロイ**
   - 本番適用時は、影響範囲を確認しながら慎重に実施

---

### 2026-02-05 Legacy: auth.ts の変更（記録訂正）

#### 訂正内容
- **誤**: 2026-02-04「Platform Admin機能の追加」で「新規作成ファイル」として記録
- **正**: legacy-baseline 時点で既に存在していたファイルへの **Legacy変更**

#### 状況・背景
- `apps/web/src/lib/auth.ts` は legacy-baseline 時点で51行で存在
- これを122行に拡張し、Platform Admin 判定ロジックを追加（70行追加）
- `isPlatformAdmin()`, `getRedirectPathForUser()` 関数を追加
- メールアドレスホワイトリストによる暫定的な Platform Admin 判定

#### 検討した選択肢
（2026-02-04 の記録を参照）

#### 決定内容
**案C（ハイブリッド方式）** を採用：メールアドレス判定 + Firestoreフラグ

#### 理由
（2026-02-04 の記録を参照）

#### 影響範囲
- **変更ファイル**:
  - `apps/web/src/lib/auth.ts:50-122` - **Legacy変更**（51行→122行、70行追加）
- **影響するコンポーネント**:
  - AuthProvider（Platform Admin 判定）
  - Platform Admin 画面へのアクセス制御
- **ユーザーへの影響**: なし（新機能追加のみ）

---

### 2026-02-05 Legacy: GAS/README.md の大幅変更（記録訂正）

#### 訂正内容
- **誤**: 2026-01-23「コードベース最適化・整合性改善」で「新規作成ファイル」として記録
- **正**: legacy-baseline 時点で既に存在していたファイルへの **Legacy変更**

#### 状況・背景
- `GAS/README.md` は legacy-baseline 時点で153行で存在
- これを212行に拡張（59行追加）
- GASシステムの詳細なドキュメント化
- Firebase との関係性の考察
- 今後のアクション提示

#### 検討した選択肢
（2026-01-23 の記録を参照）

#### 決定内容
既存の README を拡張・改善

#### 理由
- GASシステムの用途が不明確だったため、ドキュメント化が必要
- 将来の開発者への引き継ぎを容易にするため

#### 影響範囲
- **変更ファイル**:
  - `GAS/README.md:1-212` - **Legacy変更**（153行→212行、59行追加）
- **影響するコンポーネント**: なし（ドキュメントのみ）
- **ユーザーへの影響**: なし

---

### 2026-02-05 Legacy: settings/google-calendar/page.tsx の機能追加（記録漏れ修正）

#### 状況・背景
- **記録漏れの修正**: この変更は実際には過去に実施されていたが、05_decisions.mdへの記録が漏れていた
- Googleカレンダー設定ページに以下の機能を追加:
  1. **再接続機能**（`handleReconnectCalendar`）
  2. **連携解除機能の実装**（`handleDisconnectCalendar`）
- 既存ページ: legacy-baseline 時点で存在

#### 検討した選択肢
1. **案A: 新規ページを作成**
   - メリット: Legacy を一切変更しない
   - デメリット: 設定ページが分散、ユーザー体験が悪化

2. **案B: 既存ページに機能追加（実施済み）**
   - メリット: 一元管理、ユーザー体験向上
   - デメリット: Legacy変更

#### 決定内容
**案B** を採用：既存ページに機能追加

#### 理由
- Googleカレンダー連携の管理は1ページで完結すべき
- 再接続・解除機能はユーザーからの要望
- 既存のUIを活用できる

#### 影響範囲
- **変更ファイル**:
  - `apps/web/src/app/settings/google-calendar/page.tsx:268-280, 615-650` - **Legacy変更**
    - `handleReconnectCalendar` 関数追加（13行）
    - `handleDisconnectCalendar` 関数の実装（TODO→実装）（11行）
    - UIに「再接続」「解除」ボタン追加（35行）
- **影響するコンポーネント**:
  - Googleカレンダー設定ページ
  - `googleCalendarConnections` コレクション
- **ユーザーへの影響**: ポジティブ（機能追加）

#### 今後の課題
1. **動作確認**: 再接続・解除が正常に動作することを確認
2. **エラーハンドリング強化**: OAuth認証失敗時のエラーメッセージ改善

#### 反省と学習
- **Legacy変更の記録漏れ**: Medium レベルの変更であるにも関わらず、記録が漏れていた

---

### 2026-02-05 Legacy: settings/line/page.tsx の大幅機能追加（記録漏れ修正）

#### 状況・背景
- **記録漏れの修正**: この変更は実際には過去に実施されていたが、05_decisions.mdへの記録が漏れていた
- LINE設定ページに **メッセージテンプレート機能** を追加（143行追加）
- 追加された機能:
  1. **予約確認メッセージテンプレート**（bookingConfirmationMessage）
  2. **リマインダーメッセージテンプレート**（reminderMessage）
  3. **サンプルテンプレート**（formal, friendly, modern）
  4. **変数置換**（{{customerName}}, {{appointmentDate}}, etc）
  5. **プレビュー機能**
- 既存ページ: legacy-baseline 時点で存在

#### 検討した選択肢
1. **案A: デフォルトメッセージのみ（変更なし）**
   - メリット: 実装不要
   - デメリット: カスタマイズできない、サロンごとの個性が出せない

2. **案B: メッセージテンプレート機能追加（実施済み）**
   - メリット: 柔軟性、サロンごとのブランディング可能
   - デメリット: Legacy変更、実装コスト

#### 決定内容
**案B** を採用：メッセージテンプレート機能を追加

#### 理由
- サロンごとにメッセージのトーン（丁寧/親しみやすい/モダン）を変えたい
- 変数置換により、顧客名・日時などを動的に挿入可能
- サンプルテンプレートにより、初心者でも簡単に設定可能

#### 影響範囲
- **変更ファイル**:
  - `apps/web/src/app/settings/line/page.tsx:35-177` - **Legacy変更**（143行追加）
    - メッセージテンプレート state 追加
    - サンプルテンプレート定義（formal, friendly, modern）
    - テンプレート選択UI追加
    - プレビュー機能追加
- **影響するコンポーネント**:
  - LINE設定ページ
  - `lineSettings/messageTemplates` コレクション（新規）
  - `customerPortal.ts`, `lineSendMessage.ts`（テンプレート使用）
- **ユーザーへの影響**: ポジティブ（カスタマイズ機能追加）

#### 今後の課題
1. **テンプレート保存・読込の実装確認**: Firestoreへの保存・読込が正常に動作することを確認
2. **変数置換のテスト**: 全ての変数が正しく置換されることを確認
3. **プレビュー機能のテスト**: 実際のメッセージと同じ表示になることを確認

#### 反省と学習
- **Legacy変更の記録漏れ**: 大幅な機能追加であるにも関わらず、記録が漏れていた

---

### 2026-02-05 Legacy: customerPortal.ts の予約完了メッセージ送信機能追加（記録漏れ修正）

#### 状況・背景
- **記録漏れの修正**: この変更は実際には過去に実施されていたが、05_decisions.mdへの記録が漏れていた
- `createCustomerAppointment` APIに **予約完了メッセージ送信機能** を追加（97行追加）
- 追加された機能:
  1. 予約完了後、自動的にLINEメッセージを送信
  2. テンプレートメッセージの取得・変数置換
  3. デフォルトメッセージへのフォールバック
- 既存ファイル: legacy-baseline 時点で存在

#### 検討した選択肢
1. **案A: 手動でメッセージ送信**
   - メリット: 実装不要
   - デメリット: スタッフの手間、送信漏れのリスク

2. **案B: 予約完了時に自動送信（実施済み）**
   - メリット: 自動化、確実な送信、ユーザー体験向上
   - デメリット: Legacy変更、エラーハンドリングが必要

#### 決定内容
**案B** を採用：予約完了時に自動的にメッセージ送信

#### 理由
- 顧客体験の向上（予約完了を即座に通知）
- スタッフの手間削減
- 送信漏れの防止
- テンプレートメッセージとの連携

#### 影響範囲
- **変更ファイル**:
  - `backend/functions/src/api/customerPortal.ts:407-503` - **Legacy変更**（97行追加）
    - テナント情報取得
    - 顧客情報取得
    - サービス名取得
    - 日時フォーマット
    - テンプレート取得・変数置換
    - LINEメッセージ送信
- **影響するコンポーネント**:
  - 顧客ポータル予約API
  - LINE メッセージ送信
  - `lineSettings/messageTemplates` コレクション
- **ユーザーへの影響**: ポジティブ（自動通知）

#### 今後の課題
1. **エラーハンドリングの強化**: LINE API エラー時の処理改善
2. **送信ログの記録**: メッセージ送信履歴を記録
3. **送信タイミングの調整**: 即座ではなく、数分後に送信するオプション

#### 反省と学習
- **Legacy変更の記録漏れ**: Medium レベルの機能追加であるにも関わらず、記録が漏れていた

---

### 2026-02-05 Legacy: lineSendMessage.ts のリマインダーメッセージテンプレート対応（記録漏れ修正）

#### 状況・背景
- **記録漏れの修正**: この変更は実際には過去に実施されていたが、05_decisions.mdへの記録が漏れていた
- `sendAppointmentReminders` APIに **テンプレートメッセージ対応** を追加（約30行追加）
- 追加された機能:
  1. カスタムテンプレートの取得
  2. 変数置換（{{customerName}}, {{appointmentDate}}, etc）
  3. デフォルトメッセージへのフォールバック
- 既存ファイル: legacy-baseline 時点で存在

#### 検討した選択肢
1. **案A: デフォルトメッセージのみ（変更なし）**
   - メリット: 実装不要
   - デメリット: カスタマイズできない

2. **案B: テンプレートメッセージ対応（実施済み）**
   - メリット: 予約確認メッセージと統一された体験
   - デメリット: Legacy変更

#### 決定内容
**案B** を採用：テンプレートメッセージ対応

#### 理由
- 予約確認メッセージとリマインダーメッセージの体験を統一
- サロンごとのブランディング
- 既存のテンプレート機能との連携

#### 影響範囲
- **変更ファイル**:
  - `backend/functions/src/api/lineSendMessage.ts:234-257` - **Legacy変更**（約30行追加）
    - 顧客名取得
    - テンプレート取得・変数置換
    - デフォルトメッセージへのフォールバック
- **影響するコンポーネント**:
  - リマインダー送信API
  - `lineSettings/messageTemplates` コレクション
- **ユーザーへの影響**: ポジティブ（カスタマイズ可能）

#### 今後の課題
1. **テンプレートの一貫性確認**: 予約確認とリマインダーで変数が統一されているか確認

#### 反省と学習
- **Legacy変更の記録漏れ**: Medium レベルの変更であるにも関わらず、記録が漏れていた

---

### 2026-02-05 Legacy: check-emulator-data.js と tsconfig.json の変更（記録漏れ修正）

#### 状況・背景
- **記録漏れの修正**: この変更は実際には過去に実施されていたが、05_decisions.mdへの記録が漏れていた
- `check-emulator-data.js`: ES Module化、大幅な簡素化（63行→30行）
- `backend/functions/tsconfig.json`: テストファイルを exclude に追加（1行変更）

#### 検討した選択肢
1. **案A: 変更しない**
   - メリット: リスクなし
   - デメリット: CommonJS のまま、保守性低下

2. **案B: ES Module化・簡素化（実施済み）**
   - メリット: モダンな記法、保守性向上
   - デメリット: Legacy変更

#### 決定内容
**案B** を採用

#### 理由
- ES Module への移行（プロジェクト全体の方針）
- コードの簡素化
- テストファイルの exclude 追加（ビルド速度向上）

#### 影響範囲
- **変更ファイル**:
  - `check-emulator-data.js:1-30` - **Legacy変更**（ES Module化、63行→30行）
  - `backend/functions/tsconfig.json:13` - **Legacy変更**（exclude に `src/__tests__` 追加）
- **影響するコンポーネント**:
  - Emulator データ確認スクリプト
  - TypeScript ビルド
- **ユーザーへの影響**: なし（開発環境のみ）

#### 反省と学習
- **Legacy変更の記録漏れ**: Low レベルの変更であるが、記録すべきだった

---

**最終更新**: 2026-02-05
**次回見直し**: 月次レビュー時

### 2026-02-06 Legacy: スタッフ用カレンダー連携に直接接続ボタン追加

#### 状況・背景
- ユーザーからの指摘：「google-calendarページで、スタッフ用カレンダー連携の接続方法が統一されていないのではないですか？」
- 既存の問題：
  - **お店用カレンダー連携**: 「お店用カレンダーを連携」ボタン → 即座にOAuth認証
  - **スタッフ用カレンダー連携**: 「連携URLを生成」ボタン → URL送信 → スタッフが各自で認証
  - 接続方法が統一されておらず、ユーザーが混乱
- ユーザーの期待：スタッフ用でも「接続ボタン」があるはず

#### 検討した選択肢
1. **案A: すべてURL生成方式に統一**
   - メリット: 一貫性があるUI/UX
   - デメリット: お店用も管理者が直接連携できなくなる

2. **案B: すべて直接OAuth認証方式に統一**
   - メリット: よりシンプルなフロー
   - デメリット: リモートのスタッフが自分で連携できなくなる

3. **案C: 両方のボタンを並べて搭載（実施済み）**
   - メリット:
     - 目の前にいるスタッフ → 「今すぐ連携」で即座にOAuth認証
     - リモートのスタッフ → 「URL生成」でURLを送信して各自で認証
     - 柔軟性が高い、使い分け可能
   - デメリット: UIが若干複雑になる

#### 決定内容
**案C** を採用し、以下を実施：

1. **直接OAuth認証機能の追加**
   - `handleConnectStaffCalendar` 関数を追加
   - お店用カレンダー連携と同じ方式（`/api/auth/google-calendar/authorize?tenantId=...&userId=...`）

2. **UIの改善**
   - 未連携スタッフに2つのボタンを表示：
     - 「今すぐ連携」ボタン（緑色、目立つ）
     - 「URL生成」ボタン（アウトライン）
   - 説明文を更新：
     - 方法1: 今すぐ連携（推奨）
     - 方法2: URLを送信

#### 理由
- **ユーザーの要望**: 「接続ボタンがあったはず」という記憶に基づく改善要望
- **柔軟性**: 2つの方法を併用することで、様々なシチュエーションに対応
- **ユーザー体験の向上**: お店用とスタッフ用で接続方法の選択肢が統一される

#### 影響範囲
- **変更ファイル**:
  - `apps/web/src/app/settings/google-calendar/page.tsx:305-314` - **Legacy変更**（`handleConnectStaffCalendar` 関数追加）
  - `apps/web/src/app/settings/google-calendar/page.tsx:665-693` - **Legacy変更**（UI変更、2つのボタン追加）
  - `apps/web/src/app/settings/google-calendar/page.tsx:702-721` - **Legacy変更**（説明文更新）
- **影響するコンポーネント**:
  - Googleカレンダー設定ページのスタッフ用連携セクション
- **ユーザーへの影響**: ポジティブ（UI/UX改善、より柔軟な連携方法）

#### 代替案を選ばなかった理由
- **案A**: お店用も管理者が直接連携できなくなり、不便
- **案B**: リモートのスタッフが自分で連携できなくなり、柔軟性が失われる

#### 今後の課題
1. **動作確認**: 「今すぐ連携」ボタンが正常に動作することを確認
2. **ユーザーテスト**: 2つのボタンがあることで混乱しないか確認
3. **ドキュメント更新**: 連携方法のガイドを更新

#### 反省と学習
- **ユーザーの記憶との照合**: ユーザーが「以前はこうだったはず」と言う場合、実際にはそうではなくても、期待される動作として実装する価値がある
- **柔軟性の重要性**: 1つの方法に統一するのではなく、複数の方法を提供することで様々なニーズに対応できる

---

